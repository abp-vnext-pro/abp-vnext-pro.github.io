import{_ as s,c as i,o as e,ak as n}from"./chunks/framework.Be0JZvgR.js";const k=JSON.parse('{"title":"C#API客户端代理","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"guide/basic/csharpclientproxy.md","filePath":"guide/basic/csharpclientproxy.md","lastUpdated":1745041295000}'),l={name:"guide/basic/csharpclientproxy.md"};function t(p,a,r,o,h,c){return e(),i("div",null,a[0]||(a[0]=[n(`<h1 id="c-api客户端代理" tabindex="-1">C#API客户端代理 <a class="header-anchor" href="#c-api客户端代理" aria-label="Permalink to &quot;C#API客户端代理&quot;">​</a></h1><ul><li>ABP可以动态创建 C# API 客户端代理来调用您的远程 HTTP 服务 （REST API）。这样，您无需通过自定义httpclient来调用你的接口。</li><li>我们发现创建的abp项目都有一层xxx.HttpApi.Client的项目，这个模块就是用来生成客户端代理的。</li></ul><h2 id="如何使用" tabindex="-1">如何使用 <a class="header-anchor" href="#如何使用" aria-label="Permalink to &quot;如何使用&quot;">​</a></h2><ul><li>比如我们封装了一个BookStore的模块，并且打包成了服务，并单独部署，假设部署的访问端口是<a href="http://localhost:44111" target="_blank" rel="noreferrer">http://localhost:44111</a>,</li><li>按照我们以前如果需要去调用这个服务，需要通过httpclient来处理。</li><li>abp已经帮我们封装好了。我们只需要在我们需要调用的层添加BookStore.HttpApi.Client的引用，然后注册模块依赖。</li></ul><h3 id="配置" tabindex="-1">配置 <a class="header-anchor" href="#配置" aria-label="Permalink to &quot;配置&quot;">​</a></h3><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;RemoteServices&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // BookStoreService 这个名字在BookStore.HttpApi.Client的module定义</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;BookStoreService&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;BaseUrl&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://localhost:44111/&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="调用接口" tabindex="-1">调用接口 <a class="header-anchor" href="#调用接口" aria-label="Permalink to &quot;调用接口&quot;">​</a></h3><ul><li>这个时候直接注入BookStore的service接口就可以在你的其他服务中调用BookStore服务了。</li></ul>`,8)]))}const u=s(l,[["render",t]]);export{k as __pageData,u as default};
